코틀린 문법

세미콜론x 변수명은 그대로
 
자료형 첫글자는 대문자로(모두 클래스라서)
var - 일반적, null 허용x,  허용시 ?붙임 --> var a:int?
val - final
const val - 상수, 기본 자료형만 가능(String포함)
예시) var a:Int = 123  
스트링 여러줄은 """    ~~ """
따옴표 안에서 변수 출력은 $변수명 or ${인스턴스변수.변수명}
Any - ==Object같이 모든 자료형 포함
명시적 형변환은 변수.to~~~, 묵시적 형변환X
배열은 클래스로 생성 arrayOf(1,2,3) or arrayOfNulls<Int>(3)
코틀린의 타입 추론 초기화 할때나 그럴땐 타입추론


함수  반환형 생략가능
fun 함수명(변수명: 자료형,변수명: 자료형,): 반환형{
}

단일 표현식 함수
fun 함수명(변수명: 자료형,변수명: 자료형,) = ~~~

연산자
변수 is 자료형  --> 호환되는지 확인, 형변환 진행
and or == 비트연산 논리연산자는 그대로
조건문
when(변수){
1 -> println("~~")
"asd" -> println("~~")
is Long -> println("~~")
!is Int -> println("~~")
else -> println("다아님")
} -->값으로 할수도 동작으로 할수도

반복문
for( i in 0..9 step 3){
}
for( i in 0 downTo 9){
}

레이블 정하기 @
레이블이름@for(~~){
	for(~~~){
	if(~~) break@레이블이름
}} 하면 바깥쪽 for문 break

클래스            이 밑에는 주 생성자를 나타냄
class 클래스명(var 변수명:자료형,val 변수명:자료형)
생성자--> init{ ... }
보조생성자--> constructor(변수명:자료형) : this(변수명,상수값){ ... }
init은 클래스 이름 옆의 속성 그대로 다 넣었을때 실행
constructor는 c++의 위임생성자처럼 init과 디폴트 값 선언
디폴트 값 지정 가능

상속 
class 클래스명(속성값들) : 슈퍼클래스(넘길속성값)   -->주 생성자 넣음

고차함수 - 인스턴스처럼취급,파라미터로 넘기기와 결과값으로 반환 받기 가능
인스턴스방법
fun b(함수이름: 자료형){ 함수이름("파라미터")  }  --> 자료형은 (인자값 자료형,...) -> 반환형(없으면 Unit)
호출시 파라미터로 '   ::함수이름   ' 으로 넣어줌

람다함수(자체로 고차함수)
예시) val a: (파라미터)->반환형 = { 파라미터,... -> 구문 }
혹은 타입 추론으로 val a = {파라미터:자료형,... -> 구문  }

스코프함수
함수 생성자or변수뒤에 .키워드 { ... } 하면 해당 구문을 다른 스코프로 감싸서 실행
키워드는 처리가 끝나면 인스턴스반환(apply/also) 최종값 반환(run/let/with(인자))
also,let은 it으로 해당하는 인스턴스의 변수임을	 가르킴으로 바깥의 스코프와 중복되지않게함

object 이름{ .. } == static 클래스와 같음
클래스 내의 companion object{ ... } 은 static 함수와 같음 안에는 값 저장으로 사용, const val 저장

익명클래스
object:{}?

옵저버패턴(리스너)
인터페이스로 공유할 함수만든 후
행동할 클래스는 인터페이스를 인자로 받고 다른 함수로 이벤트 발생시 인터페이스의 함수 호출
인터페이스를 정의하고 클래스에 넘겨줌으로 이벤트 등록하고 실행 함수를 실행함으로 이벤트 옵저버 시작

캐스팅연산자
a as b 는 a를 b로 캐스팅하고 반환
a is b 는 캐스팅 되는지 확인하고 변환하는데 if문 안에서만 잠시 변환

제네릭   T:수퍼클래스명 --> 수퍼클래스를 상속받은 클래스만 가능
class 클래스명<T>  ,  fun<T> 함수명(var 변수명:T){...}  타입추론 ㄱㄴ

null safe 연산자
널러블변수(var str:String?)일땐 null체크없이는 컴파일X이므로
?. - str?.length >> null이라면 뒤구문 실행X
?: - str?:"asdf".length >> null이면 "asdf"로 대체돼서 실행
!!. - null를 확인하지않고 null pointer exception을 실행하도록 방치

Equals()
Any(자바의 Object)에서 equals는 정의돼어있음 커스텀클래스는 따로 정의 디폴트는 주소
==으로 equlas로 비교, ===으로 객체 주소로 비교 할 수 있음

vararg
인자값을 여러개 받기 가능, 맨마지막에만 기술 가능 예시)fun a(vararg a:Int){}

연산자 오버로딩 'infix' 키워드   (단일표현식함수로 예시)
infix fun 왼쪽자료형.연산자이름(오른쪽자료형): 리턴형 = ~~~
예시) infix fun Int.multiply(x: Int):Int = this*x

내부 중첩 클래스
중첩클래스는 클래스 안에 클래스를 기술하는것이지만 별개의 클래스, 접근은 외부.내부
내부클래스는 inner 키워드를 앞에 붙여 외부 클래스의 속성 함수 사용가능, 외부와 같이생성

특이 클래스 ( data, enum) 키워드 사용
data class ~~~ 는 equals,hashcode,toString,copy,component~의 함수 자동 지원
component1하면 첫번째 속성의 값을 가져오는데 for ( (a,b) in dataClassList) 로 자동으로 사용가능
enum class~~~는 상수값(객체)	을 모아놓는거와 같음 파이썬의 enum과 유사, 함수도 가능

콜랙션 함수 --> 컬랙션변수.키워드{ ... } , 람다함수형식으로 사용 파이썬과 유사
forEach - 순서대로 반복, filter - 조건맞는거만 반환, map - 값을 일괄적 변경, 
객체배열에서 associateBy - 키값을뽑아내 Map으로 변환, groupBy - key를 기준으로 묶어 Map, partiotion - 조건으로 나눔

코루틴 - 쓰레드?